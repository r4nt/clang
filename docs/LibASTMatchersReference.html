<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
          "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>AST Matcher Reference</title>
<link type="text/css" rel="stylesheet" href="../menu.css" />
<link type="text/css" rel="stylesheet" href="../content.css" />
<style type="text/css">
td {
  padding: .33em;
}
td.doc {
  display: none;
  border-bottom: 1px solid black;
}
td.name:hover {
  color: blue;
  cursor: pointer;
}
</style>
<script type="text/javascript">
function toggle(td) {
  row = document.getElementById(td.innerText);
  if (row.style.display != 'table-cell')
    row.style.display = 'table-cell';
  else
    row.style.display = 'none';
}
</script>
</head>
<body>

<!--#include virtual="../menu.html.incl"-->

<div id="content">

<!-- Copy & adapt those:
<tr><td>Matcher&lt;><td class="name" onclick="toggle(this)"></td></td><td>Matcher&lt;> Inner1, ...</td></tr>
<tr><td colspan="3" class="doc" id=""></td></tr>
-->

<h1>AST Matcher Reference</h1>

<!-- ======================================================================= -->
<h2 id="logic-matchers">Logic Matchers</h2>
<!-- ======================================================================= -->

<table>
<tr style="text-align:left"><th>Return type</th><th>Name</th><th>Parameters</th></tr>
</table>

<!-- ======================================================================= -->
<h2 id="generic-traversal">Generic AST Traversal Matchers</h2>
<!-- ======================================================================= -->

<table>
<tr style="text-align:left"><th>Return type</th><th>Name</th><th>Parameters</th></tr>
</table>

<!-- ======================================================================= -->
<h2 id="decl-matchers">Node Matcher</h2>
<!-- ======================================================================= -->

<table>
<tr style="text-align:left"><th>Return type</th><th>Name</th><th>Parameters</th></tr>
<!-- START_DECL_MATCHERS -->

<tr><td>Matcher&lt;Decl&gt;</td><td class="name" onclick="toggle(this)">classTemplate</td><td>Matcher&lt;ClassTemplateDecl&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="classTemplate"><pre>\brief Matches C++ class template declarations.

Example matches Z
  template&lt;class T> class Z {};
</pre></td></tr>


<tr><td>Matcher&lt;Decl&gt;</td><td class="name" onclick="toggle(this)">classTemplateSpecialization</td><td>Matcher&lt;ClassTemplateSpecializationDecl&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="classTemplateSpecialization"><pre>\brief Matches C++ class template specializations.

Given
  template&lt;typename T> class A {};
  template&lt;> class A&lt;double> {};
  A&lt;int> a;
classTemplateSpecialization()
  matches the specializations \c A&lt;int> and \c A&lt;double>
</pre></td></tr>


<tr><td>Matcher&lt;Decl&gt;</td><td class="name" onclick="toggle(this)">constructor</td><td>Matcher&lt;CXXConstructorDecl&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="constructor"><pre>\brief Matches C++ constructor declarations.

Example matches Foo::Foo() and Foo::Foo(int)
  class Foo {
   public:
    Foo();
    Foo(int);
    int DoSomething();
  };
</pre></td></tr>


<tr><td>Matcher&lt;Decl&gt;</td><td class="name" onclick="toggle(this)">decl</td><td>Matcher&lt;Decl&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="decl"><pre>\brief Matches declarations.

Examples matches \c X, \c C, and the friend declaration inside \c C;
\code
  void X();
  class C {
    friend X;
  };
\endcode
</pre></td></tr>


<tr><td>Matcher&lt;Decl&gt;</td><td class="name" onclick="toggle(this)">destructor</td><td>Matcher&lt;CXXDestructorDecl&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="destructor"><pre>\brief Matches explicit C++ destructor declarations.

Example matches Foo::~Foo()
  class Foo {
   public:
    virtual ~Foo();
  };
</pre></td></tr>


<tr><td>Matcher&lt;Decl&gt;</td><td class="name" onclick="toggle(this)">enumConstant</td><td>Matcher&lt;EnumConstantDecl&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="enumConstant"><pre>\brief Matches enum constants.

Example matches A, B, C
  enum X {
    A, B, C
  };
</pre></td></tr>


<tr><td>Matcher&lt;Decl&gt;</td><td class="name" onclick="toggle(this)">enumDecl</td><td>Matcher&lt;EnumDecl&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="enumDecl"><pre>\brief Matches enum declarations.

Example matches X
  enum X {
    A, B, C
  };
</pre></td></tr>


<tr><td>Matcher&lt;Decl&gt;</td><td class="name" onclick="toggle(this)">field</td><td>Matcher&lt;FieldDecl&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="field"><pre>\brief Matches field declarations.

Given
  class X { int m; };
field()
  matches 'm'.
</pre></td></tr>


<tr><td>Matcher&lt;Decl&gt;</td><td class="name" onclick="toggle(this)">function</td><td>Matcher&lt;FunctionDecl&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="function"><pre>\brief Matches function declarations.

Example matches f
  void f();
</pre></td></tr>


<tr><td>Matcher&lt;Decl&gt;</td><td class="name" onclick="toggle(this)">functionTemplate</td><td>Matcher&lt;FunctionTemplateDecl&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="functionTemplate"><pre>\brief Matches C++ function template declarations.

Example matches f
  template&lt;class T> void f(T t) {}
</pre></td></tr>


<tr><td>Matcher&lt;Decl&gt;</td><td class="name" onclick="toggle(this)">method</td><td>Matcher&lt;CXXMethodDecl&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="method"><pre>\brief Matches method declarations.

Example matches y
  class X { void y() };
</pre></td></tr>


<tr><td>Matcher&lt;Decl&gt;</td><td class="name" onclick="toggle(this)">nameableDeclaration</td><td>Matcher&lt;NamedDecl&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="nameableDeclaration"><pre>\brief Matches a declaration of anything that could have a name.

Example matches X, S, the anonymous union type, i, and U;
  typedef int X;
  struct S {
    union {
      int i;
    } U;
  };
</pre></td></tr>


<tr><td>Matcher&lt;Decl&gt;</td><td class="name" onclick="toggle(this)">record</td><td>Matcher&lt;CXXRecordDecl&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="record"><pre>\brief Matches C++ class declarations.

Example matches X, Z
  class X;
  template&lt;class T> class Z {};
</pre></td></tr>


<tr><td>Matcher&lt;Decl&gt;</td><td class="name" onclick="toggle(this)">usingDecl</td><td>Matcher&lt;UsingDecl&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="usingDecl"><pre>\brief Matches using declarations.

Given
  namespace X { int x; }
  using X::x;
usingDecl()
  matches \code using X::x \endcode
</pre></td></tr>


<tr><td>Matcher&lt;Decl&gt;</td><td class="name" onclick="toggle(this)">variable</td><td>Matcher&lt;VarDecl&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="variable"><pre>\brief Matches variable declarations.

Note: this does not match declarations of member variables, which are
"field" declarations in Clang parlance.

Example matches a
  int a;
</pre></td></tr>


<tr><td>Matcher&lt;Expr&gt;</td><td class="name" onclick="toggle(this)">boolLiteral</td><td>Matcher&lt;CXXBoolLiteralExpr&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="boolLiteral"><pre>\brief Matches bool literals.

Example matches true
  true
</pre></td></tr>


<tr><td>Matcher&lt;Expr&gt;</td><td class="name" onclick="toggle(this)">castExpr</td><td>Matcher&lt;CastExpr&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="castExpr"><pre>\brief Matches any cast nodes of Clang's AST.

Example: castExpr() matches each of the following:
  (int) 3;
  const_cast&lt;Expr *>(SubExpr);
  char c = 0;
but does not match
  int i = (0);
  int k = 0;
</pre></td></tr>


<tr><td>Matcher&lt;Expr&gt;</td><td class="name" onclick="toggle(this)">characterLiteral</td><td>Matcher&lt;CharacterLiteral&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="characterLiteral"><pre>\brief Matches character literals (also matches wchar_t).

Not matching Hex-encoded chars (e.g. 0x1234, which is a IntegerLiteral),
though.

Example matches 'a', L'a'
  char ch = 'a'; wchar_t chw = L'a';
</pre></td></tr>


<tr><td>Matcher&lt;Expr&gt;</td><td class="name" onclick="toggle(this)">constCast</td><td>Matcher&lt;CXXConstCastExpr&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="constCast"><pre>\brief Matches a const_cast expression.

Example: Matches const_cast&lt;int*>(&amp;r) in
  int n = 42;
  const int&amp; r(n);
  int* p = const_cast&lt;int*>(&amp;r);
</pre></td></tr>


<tr><td>Matcher&lt;Expr&gt;</td><td class="name" onclick="toggle(this)">dynamicCast</td><td>Matcher&lt;CXXDynamicCastExpr&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="dynamicCast"><pre>\brief Matches a dynamic_cast expression.

Example:
  dynamicCast()
matches
  dynamic_cast&lt;D*>(&amp;b);
in
  struct B { virtual ~B() {} }; struct D : B {};
  B b;
  D* p = dynamic_cast&lt;D*>(&amp;b);
</pre></td></tr>


<tr><td>Matcher&lt;Expr&gt;</td><td class="name" onclick="toggle(this)">explicitCast</td><td>Matcher&lt;ExplicitCastExpr&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="explicitCast"><pre>\brief Matches explicit cast expressions.

Matches any cast expression written in user code, whether it be a
C-style cast, a functional-style cast, or a keyword cast.

Does not match implicit conversions.

Note: the name "explicitCast" is chosen to match Clang's terminology, as
Clang uses the term "cast" to apply to implicit conversions as well as to
actual cast expressions.

\see hasDestinationType.

Example: matches all five of the casts in
  int((int)(reinterpret_cast&lt;int>(static_cast&lt;int>(const_cast&lt;int>(42)))))
but does not match the implicit conversion in
  long ell = 42;
</pre></td></tr>


<tr><td>Matcher&lt;Expr&gt;</td><td class="name" onclick="toggle(this)">functionalCast</td><td>Matcher&lt;CXXFunctionalCastExpr&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="functionalCast"><pre>\brief Matches functional cast expressions

Example: Matches Foo(bar);
  Foo f = bar;
  Foo g = (Foo) bar;
  Foo h = Foo(bar);
</pre></td></tr>


<tr><td>Matcher&lt;Expr&gt;</td><td class="name" onclick="toggle(this)">implicitCast</td><td>Matcher&lt;ImplicitCastExpr&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="implicitCast"><pre>\brief Matches the implicit cast nodes of Clang's AST.

This matches many different places, including function call return value
eliding, as well as any type conversions.
</pre></td></tr>


<tr><td>Matcher&lt;Expr&gt;</td><td class="name" onclick="toggle(this)">integerLiteral</td><td>Matcher&lt;IntegerLiteral&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="integerLiteral"><pre>\brief Matches integer literals of all sizes encodings.

Not matching character-encoded integers such as L'a'.

Example matches 1, 1L, 0x1, 1U
</pre></td></tr>


<tr><td>Matcher&lt;Expr&gt;</td><td class="name" onclick="toggle(this)">reinterpretCast</td><td>Matcher&lt;CXXReinterpretCastExpr&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="reinterpretCast"><pre>\brief Matches a reinterpret_cast expression.

Either the source expression or the destination type can be matched
using has(), but hasDestinationType() is more specific and can be
more readable.

Example matches reinterpret_cast&lt;char*>(&amp;p) in
  void* p = reinterpret_cast&lt;char*>(&amp;p);
</pre></td></tr>


<tr><td>Matcher&lt;Expr&gt;</td><td class="name" onclick="toggle(this)">staticCast</td><td>Matcher&lt;CXXStaticCastExpr&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="staticCast"><pre>\brief Matches a C++ static_cast expression.

\see hasDestinationType
\see reinterpretCast

Example:
  staticCast()
matches
  static_cast&lt;long>(8)
in
  long eight(static_cast&lt;long>(8));
</pre></td></tr>


<tr><td>Matcher&lt;Expr&gt;</td><td class="name" onclick="toggle(this)">stringLiteral</td><td>Matcher&lt;StringLiteral&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="stringLiteral"><pre>\brief Matches string literals (also matches wide string literals).

Example matches "abcd", L"abcd"
  char *s = "abcd"; wchar_t *ws = L"abcd"
</pre></td></tr>


<tr><td>Matcher&lt;Stmt&gt;</td><td class="name" onclick="toggle(this)">arraySubscriptExpr</td><td>Matcher&lt;ArraySubscriptExpr&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="arraySubscriptExpr"><pre>\brief Matches array subscript expressions.

Given
  int i = a[1];
arraySubscriptExpr()
  matches "a[1]"
</pre></td></tr>


<tr><td>Matcher&lt;Stmt&gt;</td><td class="name" onclick="toggle(this)">binaryOperator</td><td>Matcher&lt;BinaryOperator&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="binaryOperator"><pre>\brief Matches binary operator expressions.

Example matches a || b
  !(a || b)
</pre></td></tr>


<tr><td>Matcher&lt;Stmt&gt;</td><td class="name" onclick="toggle(this)">bindTemporaryExpression</td><td>Matcher&lt;CXXBindTemporaryExpr&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="bindTemporaryExpression"><pre>\brief Matches nodes where temporaries are created.

Example matches FunctionTakesString(GetStringByValue())
    (matcher = bindTemporaryExpression())
  FunctionTakesString(GetStringByValue());
  FunctionTakesStringByPointer(GetStringPointer());
</pre></td></tr>


<tr><td>Matcher&lt;Stmt&gt;</td><td class="name" onclick="toggle(this)">call</td><td>Matcher&lt;CallExpr&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="call"><pre>\brief Matches call expressions.

Example matches x.y() and y()
  X x;
  x.y();
  y();
</pre></td></tr>


<tr><td>Matcher&lt;Stmt&gt;</td><td class="name" onclick="toggle(this)">compoundStatement</td><td>Matcher&lt;CompoundStmt&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="compoundStatement"><pre>\brief Matches compound statements.

Example matches '{}' and '{{}}'in 'for (;;) {{}}'
  for (;;) {{}}
</pre></td></tr>


<tr><td>Matcher&lt;Stmt&gt;</td><td class="name" onclick="toggle(this)">conditionalOperator</td><td>Matcher&lt;ConditionalOperator&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="conditionalOperator"><pre>\brief Matches conditional operator expressions.

Example matches a ? b : c
  (a ? b : c) + 42
</pre></td></tr>


<tr><td>Matcher&lt;Stmt&gt;</td><td class="name" onclick="toggle(this)">constructorCall</td><td>Matcher&lt;CXXConstructExpr&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="constructorCall"><pre>\brief Matches constructor call expressions (including implicit ones).

Example matches string(ptr, n) and ptr within arguments of f
    (matcher = constructorCall())
  void f(const string &amp;a, const string &amp;b);
  char *ptr;
  int n;
  f(string(ptr, n), ptr);
</pre></td></tr>


<tr><td>Matcher&lt;Stmt&gt;</td><td class="name" onclick="toggle(this)">declarationReference</td><td>Matcher&lt;DeclRefExpr&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="declarationReference"><pre>\brief Matches expressions that refer to declarations.

Example matches x in if (x)
  bool x;
  if (x) {}
</pre></td></tr>


<tr><td>Matcher&lt;Stmt&gt;</td><td class="name" onclick="toggle(this)">declarationStatement</td><td>Matcher&lt;DeclStmt&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="declarationStatement"><pre>\brief Matches declaration statements.

Given
  int a;
declarationStatement()
  matches 'int a'.
</pre></td></tr>


<tr><td>Matcher&lt;Stmt&gt;</td><td class="name" onclick="toggle(this)">defaultArgument</td><td>Matcher&lt;CXXDefaultArgExpr&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="defaultArgument"><pre>\brief Matches the value of a default argument at the call site.

Example matches the CXXDefaultArgExpr placeholder inserted for the
    default value of the second parameter in the call expression f(42)
    (matcher = defaultArgument())
  void f(int x, int y = 0);
  f(42);
</pre></td></tr>


<tr><td>Matcher&lt;Stmt&gt;</td><td class="name" onclick="toggle(this)">deleteExpression</td><td>Matcher&lt;CXXDeleteExpr&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="deleteExpression"><pre>\brief Matches delete expressions.

Given
  delete X;
deleteExpression()
  matches 'delete X'.
</pre></td></tr>


<tr><td>Matcher&lt;Stmt&gt;</td><td class="name" onclick="toggle(this)">doStmt</td><td>Matcher&lt;DoStmt&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="doStmt"><pre>\brief Matches do statements.

Given
  do {} while (true);
doStmt()
  matches 'do {} while(true)'
</pre></td></tr>


<tr><td>Matcher&lt;Stmt&gt;</td><td class="name" onclick="toggle(this)">expression</td><td>Matcher&lt;Expr&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="expression"><pre>\brief Matches expressions.

Example matches x()
  void f() { x(); }
</pre></td></tr>


<tr><td>Matcher&lt;Stmt&gt;</td><td class="name" onclick="toggle(this)">forStmt</td><td>Matcher&lt;ForStmt&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="forStmt"><pre>\brief Matches for statements.

Example matches 'for (;;) {}'
  for (;;) {}
</pre></td></tr>


<tr><td>Matcher&lt;Stmt&gt;</td><td class="name" onclick="toggle(this)">ifStmt</td><td>Matcher&lt;IfStmt&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="ifStmt"><pre>\brief Matches if statements.

Example matches 'if (x) {}'
  if (x) {}
</pre></td></tr>


<tr><td>Matcher&lt;Stmt&gt;</td><td class="name" onclick="toggle(this)">initListExpr</td><td>Matcher&lt;InitListExpr&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="initListExpr"><pre>\brief Matches init list expressions.

Given
  int a[] = { 1, 2 };
  struct B { int x, y; };
  B b = { 5, 6 };
initList()
  matches "{ 1, 2 }" and "{ 5, 6 }"
</pre></td></tr>


<tr><td>Matcher&lt;Stmt&gt;</td><td class="name" onclick="toggle(this)">memberCall</td><td>Matcher&lt;CXXMemberCallExpr&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="memberCall"><pre>\brief Matches member call expressions.

Example matches x.y()
  X x;
  x.y();
</pre></td></tr>


<tr><td>Matcher&lt;Stmt&gt;</td><td class="name" onclick="toggle(this)">memberExpression</td><td>Matcher&lt;MemberExpr&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="memberExpression"><pre>\brief Matches member expressions.

Given
  class Y {
    void x() { this->x(); x(); Y y; y.x(); a; this->b; Y::b; }
    int a; static int b;
  };
memberExpression()
  matches this->x, x, y.x, a, this->b
</pre></td></tr>


<tr><td>Matcher&lt;Stmt&gt;</td><td class="name" onclick="toggle(this)">newExpression</td><td>Matcher&lt;CXXNewExpr&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="newExpression"><pre>\brief Matches new expressions.

Given
  new X;
newExpression()
  matches 'new X'.
</pre></td></tr>


<tr><td>Matcher&lt;Stmt&gt;</td><td class="name" onclick="toggle(this)">overloadedOperatorCall</td><td>Matcher&lt;CXXOperatorCallExpr&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="overloadedOperatorCall"><pre>\brief Matches overloaded operator calls.

Note that if an operator isn't overloaded, it won't match. Instead, use
binaryOperator matcher.
Currently it does not match operators such as new delete.
FIXME: figure out why these do not match?

Example matches both operator&lt;&lt;((o &lt;&lt; b), c) and operator&lt;&lt;(o, b)
    (matcher = overloadedOperatorCall())
  ostream &amp;operator&lt;&lt; (ostream &amp;out, int i) { };
  ostream &amp;o; int b = 1, c = 1;
  o &lt;&lt; b &lt;&lt; c;
</pre></td></tr>


<tr><td>Matcher&lt;Stmt&gt;</td><td class="name" onclick="toggle(this)">statement</td><td>Matcher&lt;Stmt&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="statement"><pre>\brief Matches statements.

Given
  { ++a; }
statement()
  matches both the compound statement '{ ++a; }' and '++a'.
</pre></td></tr>


<tr><td>Matcher&lt;Stmt&gt;</td><td class="name" onclick="toggle(this)">switchCase</td><td>Matcher&lt;SwitchCase&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="switchCase"><pre>\brief Matches case and default statements inside switch statements.

Given
  switch(a) { case 42: break; default: break; }
switchCase()
  matches 'case 42: break;' and 'default: break;'.
</pre></td></tr>


<tr><td>Matcher&lt;Stmt&gt;</td><td class="name" onclick="toggle(this)">unaryExprOrTypeTraitExpr</td><td>Matcher&lt;UnaryExprOrTypeTraitExpr&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="unaryExprOrTypeTraitExpr"><pre>\brief Matches sizeof (C99), alignof (C++11) and vec_step (OpenCL)

Given
  Foo x = bar;
  int y = sizeof(x) + alignof(x);
unaryExprOrTypeTraitExpr()
  matches \c sizeof(x) and \c alignof(x)
</pre></td></tr>


<tr><td>Matcher&lt;Stmt&gt;</td><td class="name" onclick="toggle(this)">unaryOperator</td><td>Matcher&lt;UnaryOperator&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="unaryOperator"><pre>\brief Matches unary operator expressions.

Example matches !a
  !a || b
</pre></td></tr>


<tr><td>Matcher&lt;Stmt&gt;</td><td class="name" onclick="toggle(this)">whileStmt</td><td>Matcher&lt;WhileStmt&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="whileStmt"><pre>\brief Matches while statements.

Given
  while (true) {}
whileStmt()
  matches 'while (true) {}'.
</pre></td></tr>

<!--END_DECL_MATCHERS -->
</table>

<!-- ======================================================================= -->
<h2 id="narrowing-matchers">Narrowing Matchers</h2>
<!-- ======================================================================= -->

<table>
<tr style="text-align:left"><th>Return type</th><th>Name</th><th>Parameters</th></tr>
<!-- START_NARROWING_MATCHERS -->

<tr><td>Matcher&lt;*&gt;</td><td class="name" onclick="toggle(this)">allOf</td><td>const C1 &amp;P1, const C2 &amp;P2</td></tr>
<tr><td colspan="4" class="doc" id="allOf"><pre>\brief Matches if all given matchers match.

Usable as: Any Matcher
</pre></td></tr>


<tr><td>Matcher&lt;*&gt;</td><td class="name" onclick="toggle(this)">anyOf</td><td>const C1 &amp;P1, const C2 &amp;P2</td></tr>
<tr><td colspan="4" class="doc" id="anyOf"><pre>\brief Matches if any of the given matchers matches.

Usable as: Any Matcher
</pre></td></tr>


<tr><td>Matcher&lt;*&gt;</td><td class="name" onclick="toggle(this)">anything</td><td></td></tr>
<tr><td colspan="4" class="doc" id="anything"><pre>\brief Matches any node.

Useful when another matcher requires a child matcher, but there's no
additional constraint. This will often be used with an explicit conversion
to a internal::Matcher&lt;> type such as TypeMatcher.

Example: DeclarationMatcher(anything()) matches all declarations, e.g.,
"int* p" and "void f()" in
  int* p;
  void f();

Usable as: Any Matcher
</pre></td></tr>


<tr><td>Matcher&lt;*&gt;</td><td class="name" onclick="toggle(this)">unless</td><td>const M &amp;InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="unless"><pre>\brief Matches if the provided matcher does not match.

Example matches Y (matcher = record(unless(hasName("X"))))
  class X {};
  class Y {};

Usable as: Any Matcher
</pre></td></tr>


<tr><td>Matcher&lt;BinaryOperator&gt;</td><td class="name" onclick="toggle(this)">hasOperatorName</td><td>std::string Name</td></tr>
<tr><td colspan="4" class="doc" id="hasOperatorName"><pre>\brief Matches the operator Name of operator expressions (binary or
unary).

Example matches a || b (matcher = binaryOperator(hasOperatorName("||")))
  !(a || b)
</pre></td></tr>


<tr><td>Matcher&lt;CXXBoolLiteral&gt;</td><td class="name" onclick="toggle(this)">equals</td><td>const ValueT &amp;Value</td></tr>
<tr><td colspan="4" class="doc" id="equals"><pre>\brief Matches literals that are equal to the given value.

Example matches true (matcher = boolLiteral(equals(true)))
  true

Usable as: Matcher&lt;CharacterLiteral>, Matcher&lt;CXXBoolLiteral>,
           Matcher&lt;FloatingLiteral>, Matcher&lt;IntegerLiteral>
</pre></td></tr>


<tr><td>Matcher&lt;CXXConstructorDecl&gt;</td><td class="name" onclick="toggle(this)">isImplicit</td><td></td></tr>
<tr><td colspan="4" class="doc" id="isImplicit"><pre>\brief Matches a constructor declaration that has been implicitly added
by the compiler (eg. implicit defaultcopy constructors).
</pre></td></tr>


<tr><td>Matcher&lt;CXXCtorInitializer&gt;</td><td class="name" onclick="toggle(this)">isWritten</td><td></td></tr>
<tr><td colspan="4" class="doc" id="isWritten"><pre>\brief Matches a contructor initializer if it is explicitly written in
code (as opposed to implicitly added by the compiler).

Given
  struct Foo {
    Foo() { }
    Foo(int) : foo_("A") { }
    string foo_;
  };
constructor(hasAnyConstructorInitializer(isWritten()))
  will match Foo(int), but not Foo()
</pre></td></tr>


<tr><td>Matcher&lt;CXXOperatorCallExpr&gt;</td><td class="name" onclick="toggle(this)">hasOverloadedOperatorName</td><td>std::string Name</td></tr>
<tr><td colspan="4" class="doc" id="hasOverloadedOperatorName"><pre>\brief Matches overloaded operator names.

Matches overloaded operator names specified in strings without the
"operator" prefix, such as "&lt;&lt;", for OverloadedOperatorCall's.

Example matches a &lt;&lt; b
    (matcher == overloadedOperatorCall(hasOverloadedOperatorName("&lt;&lt;")))
  a &lt;&lt; b;
  c &amp;&amp; d;  assuming both operator&lt;&lt;
           and operator&amp;&amp; are overloaded somewhere.
</pre></td></tr>


<tr><td>Matcher&lt;CXXRecordDecl&gt;</td><td class="name" onclick="toggle(this)">isDerivedFrom</td><td>StringRef BaseName</td></tr>
<tr><td colspan="4" class="doc" id="isDerivedFrom"><pre>\brief Overloaded method as shortcut for \c isDerivedFrom(hasName(...)).
</pre></td></tr>


<tr><td>Matcher&lt;CXXRecordDecl&gt;</td><td class="name" onclick="toggle(this)">isExplicitTemplateSpecialization</td><td></td></tr>
<tr><td colspan="4" class="doc" id="isExplicitTemplateSpecialization"><pre>\brief Matches explicit template specializations of function, class, or
static member variable template instantiations.

Given
  template&lt;typename T> void A(T t) { }
  template&lt;> void A(int N) { }
function(isExplicitSpecialization())
  matches the specialization A&lt;int>().

Usable as: Matcher&lt;FunctionDecl>, Matcher&lt;VarDecl>, Matcher&lt;CXXRecordDecl>
</pre></td></tr>


<tr><td>Matcher&lt;CXXRecordDecl&gt;</td><td class="name" onclick="toggle(this)">isTemplateInstantiation</td><td></td></tr>
<tr><td colspan="4" class="doc" id="isTemplateInstantiation"><pre>\brief Matches template instantiations of function, class, or static
member variable template instantiations.

Given
  template &lt;typename T> class X {}; class A {}; X&lt;A> x;
or
  template &lt;typename T> class X {}; class A {}; template class X&lt;A>;
record(hasName("::X"), isTemplateInstantiation())
  matches the template instantiation of X&lt;A>.

But given
  template &lt;typename T> class X {}; class A {};
  template &lt;> class X&lt;A> {}; X&lt;A> x;
record(hasName("::X"), isTemplateInstantiation())
  does not match, as X&lt;A> is an explicit template specialization.

Usable as: Matcher&lt;FunctionDecl>, Matcher&lt;VarDecl>, Matcher&lt;CXXRecordDecl>
</pre></td></tr>


<tr><td>Matcher&lt;CallExpr&gt;</td><td class="name" onclick="toggle(this)">argumentCountIs</td><td>unsigned N</td></tr>
<tr><td colspan="4" class="doc" id="argumentCountIs"><pre>\brief Checks that a call expression or a constructor call expression has
a specific number of arguments (including absent default arguments).

Example matches f(0, 0) (matcher = call(argumentCountIs(2)))
  void f(int x, int y);
  f(0, 0);
</pre></td></tr>


<tr><td>Matcher&lt;CharacterLiteral&gt;</td><td class="name" onclick="toggle(this)">equals</td><td>const ValueT &amp;Value</td></tr>
<tr><td colspan="4" class="doc" id="equals"><pre>\brief Matches literals that are equal to the given value.

Example matches true (matcher = boolLiteral(equals(true)))
  true

Usable as: Matcher&lt;CharacterLiteral>, Matcher&lt;CXXBoolLiteral>,
           Matcher&lt;FloatingLiteral>, Matcher&lt;IntegerLiteral>
</pre></td></tr>


<tr><td>Matcher&lt;CompoundStmt&gt;</td><td class="name" onclick="toggle(this)">statementCountIs</td><td>unsigned N</td></tr>
<tr><td colspan="4" class="doc" id="statementCountIs"><pre>\brief Checks that a compound statement contains a specific number of
child statements.

Example: Given
  { for (;;) {} }
compoundStatement(statementCountIs(0)))
  matches '{}'
  but does not match the outer compound statement.
</pre></td></tr>


<tr><td>Matcher&lt;DeclStmt&gt;</td><td class="name" onclick="toggle(this)">declCountIs</td><td>unsigned N</td></tr>
<tr><td colspan="4" class="doc" id="declCountIs"><pre>\brief Matches declaration statements that contain a specific number of
declarations.

Example: Given
  int a, b;
  int c;
  int d = 2, e;
declCountIs(2)
  matches 'int a, b;' and 'int d = 2, e;', but not 'int c;'.
</pre></td></tr>


<tr><td>Matcher&lt;FloatingLiteral&gt;</td><td class="name" onclick="toggle(this)">equals</td><td>const ValueT &amp;Value</td></tr>
<tr><td colspan="4" class="doc" id="equals"><pre>\brief Matches literals that are equal to the given value.

Example matches true (matcher = boolLiteral(equals(true)))
  true

Usable as: Matcher&lt;CharacterLiteral>, Matcher&lt;CXXBoolLiteral>,
           Matcher&lt;FloatingLiteral>, Matcher&lt;IntegerLiteral>
</pre></td></tr>


<tr><td>Matcher&lt;FunctionDecl&gt;</td><td class="name" onclick="toggle(this)">isDefinition</td><td></td></tr>
<tr><td colspan="4" class="doc" id="isDefinition"><pre>\brief Matches if a declaration has a body attached.

Example matches A, va, fa
  class A {};
  class B;  Doesn't match, as it has no body.
  int va;
  extern int vb;  Doesn't match, as it doesn't define the variable.
  void fa() {}
  void fb();  Doesn't match, as it has no body.

Usable as: Matcher&lt;TagDecl>, Matcher&lt;VarDecl>, Matcher&lt;FunctionDecl>
</pre></td></tr>


<tr><td>Matcher&lt;FunctionDecl&gt;</td><td class="name" onclick="toggle(this)">isExplicitTemplateSpecialization</td><td></td></tr>
<tr><td colspan="4" class="doc" id="isExplicitTemplateSpecialization"><pre>\brief Matches explicit template specializations of function, class, or
static member variable template instantiations.

Given
  template&lt;typename T> void A(T t) { }
  template&lt;> void A(int N) { }
function(isExplicitSpecialization())
  matches the specialization A&lt;int>().

Usable as: Matcher&lt;FunctionDecl>, Matcher&lt;VarDecl>, Matcher&lt;CXXRecordDecl>
</pre></td></tr>


<tr><td>Matcher&lt;FunctionDecl&gt;</td><td class="name" onclick="toggle(this)">isExternC</td><td></td></tr>
<tr><td colspan="4" class="doc" id="isExternC"><pre>\brief Matches extern "C" function declarations.

Given:
  extern "C" void f() {}
  extern "C" { void g() {} }
  void h() {}
function(isExternC())
  matches the declaration of f and g, but not the declaration h
</pre></td></tr>


<tr><td>Matcher&lt;FunctionDecl&gt;</td><td class="name" onclick="toggle(this)">isTemplateInstantiation</td><td></td></tr>
<tr><td colspan="4" class="doc" id="isTemplateInstantiation"><pre>\brief Matches template instantiations of function, class, or static
member variable template instantiations.

Given
  template &lt;typename T> class X {}; class A {}; X&lt;A> x;
or
  template &lt;typename T> class X {}; class A {}; template class X&lt;A>;
record(hasName("::X"), isTemplateInstantiation())
  matches the template instantiation of X&lt;A>.

But given
  template &lt;typename T> class X {}; class A {};
  template &lt;> class X&lt;A> {}; X&lt;A> x;
record(hasName("::X"), isTemplateInstantiation())
  does not match, as X&lt;A> is an explicit template specialization.

Usable as: Matcher&lt;FunctionDecl>, Matcher&lt;VarDecl>, Matcher&lt;CXXRecordDecl>
</pre></td></tr>


<tr><td>Matcher&lt;IntegerLiteral&gt;</td><td class="name" onclick="toggle(this)">equals</td><td>const ValueT &amp;Value</td></tr>
<tr><td colspan="4" class="doc" id="equals"><pre>\brief Matches literals that are equal to the given value.

Example matches true (matcher = boolLiteral(equals(true)))
  true

Usable as: Matcher&lt;CharacterLiteral>, Matcher&lt;CXXBoolLiteral>,
           Matcher&lt;FloatingLiteral>, Matcher&lt;IntegerLiteral>
</pre></td></tr>


<tr><td>Matcher&lt;MemberExpr&gt;</td><td class="name" onclick="toggle(this)">isArrow</td><td></td></tr>
<tr><td colspan="4" class="doc" id="isArrow"><pre>\brief Matches member expressions that are called with '->' as opposed
to '.'.

Member calls on the implicit this pointer match as called with '->'.

Given
  class Y {
    void x() { this->x(); x(); Y y; y.x(); a; this->b; Y::b; }
    int a;
    static int b;
  };
memberExpression(isArrow())
  matches this->x, x, y.x, a, this->b
</pre></td></tr>


<tr><td>Matcher&lt;NamedDecl&gt;</td><td class="name" onclick="toggle(this)">hasName</td><td>std::string Name</td></tr>
<tr><td colspan="4" class="doc" id="hasName"><pre>\brief Matches NamedDecl nodes that have the specified name.

Supports specifying enclosing namespaces or classes by prefixing the name
with '&lt;enclosing>::'.
Does not match typedefs of an underlying type with the given name.

Example matches X (Name == "X")
  class X;

Example matches X (Name is one of "::a::b::X", "a::b::X", "b::X", "X")
namespace a { namespace b { class X; } }
</pre></td></tr>


<tr><td>Matcher&lt;NamedDecl&gt;</td><td class="name" onclick="toggle(this)">matchesName</td><td>std::string RegExp</td></tr>
<tr><td colspan="4" class="doc" id="matchesName"><pre>\brief Matches NamedDecl nodes whose full names partially match the
given RegExp.

Supports specifying enclosing namespaces or classes by
prefixing the name with '&lt;enclosing>::'.  Does not match typedefs
of an underlying type with the given name.

Example matches X (regexp == "::X")
  class X;

Example matches X (regexp is one of "::X", "^foo::.*X", among others)
namespace foo { namespace bar { class X; } }
</pre></td></tr>


<tr><td>Matcher&lt;QualType&gt;</td><td class="name" onclick="toggle(this)">asString</td><td>std::string Name</td></tr>
<tr><td colspan="4" class="doc" id="asString"><pre>\brief Matches if the matched type is represented by the given string.

Given
  class Y { public: void x(); };
  void z() { Y* y; y->x(); }
call(on(hasType(asString("class Y *"))))
  matches y->x()
</pre></td></tr>


<tr><td>Matcher&lt;QualType&gt;</td><td class="name" onclick="toggle(this)">isConstQualified</td><td></td></tr>
<tr><td colspan="4" class="doc" id="isConstQualified"><pre>\brief Matches QualType nodes that are const-qualified, i.e., that
include "top-level" const.

Given
  void a(int);
  void b(int const);
  void c(const int);
  void d(const int*);
  void e(int const) {};
function(hasAnyParameter(hasType(isConstQualified())))
  matches "void b(int const)", "void c(const int)" and
  "void e(int const) {}". It does not match d as there
  is no top-level const on the parameter type "const int *".
</pre></td></tr>


<tr><td>Matcher&lt;QualType&gt;</td><td class="name" onclick="toggle(this)">isInteger</td><td></td></tr>
<tr><td colspan="4" class="doc" id="isInteger"><pre>\brief Matches QualType nodes that are of integer type.

Given
  void a(int);
  void b(long);
  void c(double);
function(hasAnyParameter(hasType(isInteger())))
matches "a(int)", "b(long)", but not "c(double)".
</pre></td></tr>


<tr><td>Matcher&lt;TagDecl&gt;</td><td class="name" onclick="toggle(this)">isDefinition</td><td></td></tr>
<tr><td colspan="4" class="doc" id="isDefinition"><pre>\brief Matches if a declaration has a body attached.

Example matches A, va, fa
  class A {};
  class B;  Doesn't match, as it has no body.
  int va;
  extern int vb;  Doesn't match, as it doesn't define the variable.
  void fa() {}
  void fb();  Doesn't match, as it has no body.

Usable as: Matcher&lt;TagDecl>, Matcher&lt;VarDecl>, Matcher&lt;FunctionDecl>
</pre></td></tr>


<tr><td>Matcher&lt;UnaryExprOrTypeTraitExpr&gt;</td><td class="name" onclick="toggle(this)">ofKind</td><td>UnaryExprOrTypeTrait Kind</td></tr>
<tr><td colspan="4" class="doc" id="ofKind"><pre>\brief Matches unary expressions of a certain kind.

Given
  int x;
  int s = sizeof(x) + alignof(x)
unaryExprOrTypeTraitExpr(ofKind(UETT_SizeOf))
  matches \c sizeof(x)
</pre></td></tr>


<tr><td>Matcher&lt;UnaryOperator&gt;</td><td class="name" onclick="toggle(this)">hasOperatorName</td><td>std::string Name</td></tr>
<tr><td colspan="4" class="doc" id="hasOperatorName"><pre>\brief Matches the operator Name of operator expressions (binary or
unary).

Example matches a || b (matcher = binaryOperator(hasOperatorName("||")))
  !(a || b)
</pre></td></tr>


<tr><td>Matcher&lt;VarDecl&gt;</td><td class="name" onclick="toggle(this)">isDefinition</td><td></td></tr>
<tr><td colspan="4" class="doc" id="isDefinition"><pre>\brief Matches if a declaration has a body attached.

Example matches A, va, fa
  class A {};
  class B;  Doesn't match, as it has no body.
  int va;
  extern int vb;  Doesn't match, as it doesn't define the variable.
  void fa() {}
  void fb();  Doesn't match, as it has no body.

Usable as: Matcher&lt;TagDecl>, Matcher&lt;VarDecl>, Matcher&lt;FunctionDecl>
</pre></td></tr>


<tr><td>Matcher&lt;VarDecl&gt;</td><td class="name" onclick="toggle(this)">isExplicitTemplateSpecialization</td><td></td></tr>
<tr><td colspan="4" class="doc" id="isExplicitTemplateSpecialization"><pre>\brief Matches explicit template specializations of function, class, or
static member variable template instantiations.

Given
  template&lt;typename T> void A(T t) { }
  template&lt;> void A(int N) { }
function(isExplicitSpecialization())
  matches the specialization A&lt;int>().

Usable as: Matcher&lt;FunctionDecl>, Matcher&lt;VarDecl>, Matcher&lt;CXXRecordDecl>
</pre></td></tr>


<tr><td>Matcher&lt;VarDecl&gt;</td><td class="name" onclick="toggle(this)">isTemplateInstantiation</td><td></td></tr>
<tr><td colspan="4" class="doc" id="isTemplateInstantiation"><pre>\brief Matches template instantiations of function, class, or static
member variable template instantiations.

Given
  template &lt;typename T> class X {}; class A {}; X&lt;A> x;
or
  template &lt;typename T> class X {}; class A {}; template class X&lt;A>;
record(hasName("::X"), isTemplateInstantiation())
  matches the template instantiation of X&lt;A>.

But given
  template &lt;typename T> class X {}; class A {};
  template &lt;> class X&lt;A> {}; X&lt;A> x;
record(hasName("::X"), isTemplateInstantiation())
  does not match, as X&lt;A> is an explicit template specialization.

Usable as: Matcher&lt;FunctionDecl>, Matcher&lt;VarDecl>, Matcher&lt;CXXRecordDecl>
</pre></td></tr>

<!--END_NARROWING_MATCHERS -->
</table>

<!-- ======================================================================= -->
<h2 id="traversal-matchers">AST Traversal Matchers</h2>
<!-- ======================================================================= -->

<table>
<tr style="text-align:left"><th>Return type</th><th>Name</th><th>Parameters</th></tr>
<!-- START_TRAVERSAL_MATCHERS -->

<tr><td>Matcher&lt;*&gt;</td><td class="name" onclick="toggle(this)">forEach</td><td>const internal::Matcher&lt;ChildT>&amp; ChildMatcher</td></tr>
<tr><td colspan="4" class="doc" id="forEach"><pre>\brief Matches AST nodes that have child AST nodes that match the
provided matcher.

Example matches X, Y (matcher = record(forEach(record(hasName("X")))
  class X {};  Matches X, because X::X is a class of name X inside X.
  class Y { class X {}; };
  class Z { class Y { class X {}; }; };  Does not match Z.

ChildT must be an AST base type.

As opposed to 'has', 'forEach' will cause a match for each result that
matches instead of only on the first one.

Usable as: Any Matcher
</pre></td></tr>


<tr><td>Matcher&lt;*&gt;</td><td class="name" onclick="toggle(this)">forEachDescendant</td><td>const internal::Matcher&lt;DescendantT>&amp; DescendantMatcher</td></tr>
<tr><td colspan="4" class="doc" id="forEachDescendant"><pre>\brief Matches AST nodes that have descendant AST nodes that match the
provided matcher.

Example matches X, A, B, C
    (matcher = record(forEachDescendant(record(hasName("X")))))
  class X {};  Matches X, because X::X is a class of name X inside X.
  class A { class X {}; };
  class B { class C { class X {}; }; };

DescendantT must be an AST base type.

As opposed to 'hasDescendant', 'forEachDescendant' will cause a match for
each result that matches instead of only on the first one.

Note: Recursively combined ForEachDescendant can cause many matches:
  record(forEachDescendant(record(forEachDescendant(record()))))
will match 10 times (plus injected class name matches) on:
  class A { class B { class C { class D { class E {}; }; }; }; };

Usable as: Any Matcher
</pre></td></tr>


<tr><td>Matcher&lt;*&gt;</td><td class="name" onclick="toggle(this)">has</td><td>const internal::Matcher&lt;ChildT> &amp;ChildMatcher</td></tr>
<tr><td colspan="4" class="doc" id="has"><pre>\brief Matches AST nodes that have child AST nodes that match the
provided matcher.

Example matches X, Y (matcher = record(has(record(hasName("X")))
  class X {};  Matches X, because X::X is a class of name X inside X.
  class Y { class X {}; };
  class Z { class Y { class X {}; }; };  Does not match Z.

ChildT must be an AST base type.

Usable as: Any Matcher
</pre></td></tr>


<tr><td>Matcher&lt;*&gt;</td><td class="name" onclick="toggle(this)">hasDescendant</td><td>const internal::Matcher&lt;DescendantT> &amp;DescendantMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasDescendant"><pre>\brief Matches AST nodes that have descendant AST nodes that match the
provided matcher.

Example matches X, Y, Z
    (matcher = record(hasDescendant(record(hasName("X")))))
  class X {};  Matches X, because X::X is a class of name X inside X.
  class Y { class X {}; };
  class Z { class Y { class X {}; }; };

DescendantT must be an AST base type.

Usable as: Any Matcher
</pre></td></tr>


<tr><td>Matcher&lt;ArraySubscriptExpr&gt;</td><td class="name" onclick="toggle(this)">hasBase</td><td>internal::Matcher&lt;Expr> matcher</td></tr>
<tr><td colspan="4" class="doc" id="hasBase"><pre>\brief Matches the base expression of an array subscript expression.

Given
  int i[5];
  void f() { i[1] = 42; }
arraySubscriptExpression(hasBase(implicitCast(
    hasSourceExpression(declarationReference()))))
  matches \c i[1] with the \c declarationReference() matching \c i
</pre></td></tr>


<tr><td>Matcher&lt;ArraySubscriptExpr&gt;</td><td class="name" onclick="toggle(this)">hasIndex</td><td>internal::Matcher&lt;Expr> matcher</td></tr>
<tr><td colspan="4" class="doc" id="hasIndex"><pre>\brief Matches the index expression of an array subscript expression.

Given
  int i[5];
  void f() { i[1] = 42; }
arraySubscriptExpression(hasIndex(integerLiteral()))
  matches \c i[1] with the \c integerLiteral() matching \c 1
</pre></td></tr>


<tr><td>Matcher&lt;BinaryOperator&gt;</td><td class="name" onclick="toggle(this)">hasEitherOperand</td><td>const internal::Matcher&lt;Expr> &amp;InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasEitherOperand"><pre>\brief Matches if either the left hand side or the right hand side of a
binary operator matches.
</pre></td></tr>


<tr><td>Matcher&lt;BinaryOperator&gt;</td><td class="name" onclick="toggle(this)">hasLHS</td><td>internal::Matcher&lt;Expr> InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasLHS"><pre>\brief Matches the left hand side of binary operator expressions.

Example matches a (matcher = binaryOperator(hasLHS()))
  a || b
</pre></td></tr>


<tr><td>Matcher&lt;BinaryOperator&gt;</td><td class="name" onclick="toggle(this)">hasRHS</td><td>internal::Matcher&lt;Expr> InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasRHS"><pre>\brief Matches the right hand side of binary operator expressions.

Example matches b (matcher = binaryOperator(hasRHS()))
  a || b
</pre></td></tr>


<tr><td>Matcher&lt;CXXConstructExpr&gt;</td><td class="name" onclick="toggle(this)">hasDeclaration</td><td>const internal::Matcher&lt;Decl> &amp;InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasDeclaration"><pre>\brief Matches a type if the declaration of the type matches the given
matcher.

Usable as: Matcher&lt;QualType>, Matcher&lt;CallExpr>, Matcher&lt;CXXConstructExpr>
</pre></td></tr>


<tr><td>Matcher&lt;CXXConstructorDecl&gt;</td><td class="name" onclick="toggle(this)">hasAnyConstructorInitializer</td><td>internal::Matcher&lt;CXXCtorInitializer> InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasAnyConstructorInitializer"><pre>\brief Matches a constructor initializer.

Given
  struct Foo {
    Foo() : foo_(1) { }
    int foo_;
  };
record(has(constructor(hasAnyConstructorInitializer(anything()))))
  record matches Foo, hasAnyConstructorInitializer matches foo_(1)
</pre></td></tr>


<tr><td>Matcher&lt;CXXCtorInitializer&gt;</td><td class="name" onclick="toggle(this)">forField</td><td>internal::Matcher&lt;FieldDecl> InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="forField"><pre>\brief Matches the field declaration of a constructor initializer.

Given
  struct Foo {
    Foo() : foo_(1) { }
    int foo_;
  };
record(has(constructor(hasAnyConstructorInitializer(
    forField(hasName("foo_"))))))
  matches Foo
with forField matching foo_
</pre></td></tr>


<tr><td>Matcher&lt;CXXCtorInitializer&gt;</td><td class="name" onclick="toggle(this)">withInitializer</td><td>internal::Matcher&lt;Expr> InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="withInitializer"><pre>\brief Matches the initializer expression of a constructor initializer.

Given
  struct Foo {
    Foo() : foo_(1) { }
    int foo_;
  };
record(has(constructor(hasAnyConstructorInitializer(
    withInitializer(integerLiteral(equals(1)))))))
  matches Foo
with withInitializer matching (1)
</pre></td></tr>


<tr><td>Matcher&lt;CXXMemberCallExpr&gt;</td><td class="name" onclick="toggle(this)">on</td><td>internal::Matcher&lt;Expr> InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="on"><pre>\brief Matches on the implicit object argument of a member call expression.

Example matches y.x() (matcher = call(on(hasType(record(hasName("Y"))))))
  class Y { public: void x(); };
  void z() { Y y; y.x(); }",

FIXME: Overload to allow directly matching types?
</pre></td></tr>


<tr><td>Matcher&lt;CXXMemberCallExpr&gt;</td><td class="name" onclick="toggle(this)">onImplicitObjectArgument</td><td>internal::Matcher&lt;Expr> InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="onImplicitObjectArgument"><pre></pre></td></tr>


<tr><td>Matcher&lt;CXXMemberCallExpr&gt;</td><td class="name" onclick="toggle(this)">thisPointerType</td><td>const internal::Matcher&lt;Decl> &amp;InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="thisPointerType"><pre>\brief Overloaded to match the type's declaration.
</pre></td></tr>


<tr><td>Matcher&lt;CXXMethodDecl&gt;</td><td class="name" onclick="toggle(this)">ofClass</td><td>internal::Matcher&lt;CXXRecordDecl> InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="ofClass"><pre>\brief Matches the class declaration that the given method declaration
belongs to.

FIXME: Generalize this for other kinds of declarations.
FIXME: What other kind of declarations would we need to generalize
this to?

Example matches A() in the last line
    (matcher = constructorCall(hasDeclaration(method(
        ofClass(hasName("A"))))))
  class A {
   public:
    A();
  };
  A a = A();
</pre></td></tr>


<tr><td>Matcher&lt;CXXRecordDecl&gt;</td><td class="name" onclick="toggle(this)">isDerivedFrom</td><td>internal::Matcher&lt;NamedDecl> Base</td></tr>
<tr><td colspan="4" class="doc" id="isDerivedFrom"><pre>\brief Matches C++ classes that are directly or indirectly derived from
a class matching \c Base.

Note that a class is considered to be also derived from itself.

Example matches X, Y, Z, C (Base == hasName("X"))
  class X;                A class is considered to be derived from itself
  class Y : public X {};  directly derived
  class Z : public Y {};  indirectly derived
  typedef X A;
  typedef A B;
  class C : public B {};  derived from a typedef of X

In the following example, Bar matches isDerivedFrom(hasName("X")):
  class Foo;
  typedef Foo X;
  class Bar : public Foo {};  derived from a type that X is a typedef of
</pre></td></tr>


<tr><td>Matcher&lt;CallExpr&gt;</td><td class="name" onclick="toggle(this)">callee</td><td>const internal::Matcher&lt;Decl> &amp;InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="callee"><pre>\brief Matches if the call expression's callee's declaration matches the
given matcher.

Example matches y.x() (matcher = call(callee(method(hasName("x")))))
  class Y { public: void x(); };
  void z() { Y y; y.x();
</pre></td></tr>


<tr><td>Matcher&lt;CallExpr&gt;</td><td class="name" onclick="toggle(this)">hasAnyArgument</td><td>internal::Matcher&lt;Expr> InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasAnyArgument"><pre>\brief Matches any argument of a call expression or a constructor call
expression.

Given
  void x(int, int, int) { int y; x(1, y, 42); }
call(hasAnyArgument(declarationReference()))
  matches x(1, y, 42)
with hasAnyArgument(...)
  matching y
</pre></td></tr>


<tr><td>Matcher&lt;CallExpr&gt;</td><td class="name" onclick="toggle(this)">hasArgument</td><td>unsigned N, internal::Matcher&lt;Expr> InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasArgument"><pre>\brief Matches the n'th argument of a call expression or a constructor
call expression.

Example matches y in x(y)
    (matcher = call(hasArgument(0, declarationReference())))
  void x(int) { int y; x(y); }
</pre></td></tr>


<tr><td>Matcher&lt;CallExpr&gt;</td><td class="name" onclick="toggle(this)">hasDeclaration</td><td>const internal::Matcher&lt;Decl> &amp;InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasDeclaration"><pre>\brief Matches a type if the declaration of the type matches the given
matcher.

Usable as: Matcher&lt;QualType>, Matcher&lt;CallExpr>, Matcher&lt;CXXConstructExpr>
</pre></td></tr>


<tr><td>Matcher&lt;CastExpr&gt;</td><td class="name" onclick="toggle(this)">hasSourceExpression</td><td>internal::Matcher&lt;Expr> InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasSourceExpression"><pre>\brief Matches if the cast's source expression matches the given matcher.

Example: matches "a string" (matcher =
                                 hasSourceExpression(constructorCall()))

class URL { URL(string); };
URL url = "a string";
</pre></td></tr>


<tr><td>Matcher&lt;ClassTemplateSpecializationDecl&gt;</td><td class="name" onclick="toggle(this)">hasAnyTemplateArgument</td><td>internal::Matcher&lt;TemplateArgument> Matcher</td></tr>
<tr><td colspan="4" class="doc" id="hasAnyTemplateArgument"><pre>\brief Matches classTemplateSpecializations that have at least one
TemplateArgument matching the given Matcher.

Given
  template&lt;typename T> class A {};
  template&lt;> class A&lt;double> {};
  A&lt;int> a;
classTemplateSpecialization(hasAnyTemplateArgument(
    refersToType(asString("int"))))
  matches the specialization \c A&lt;int>
</pre></td></tr>


<tr><td>Matcher&lt;ClassTemplateSpecializationDecl&gt;</td><td class="name" onclick="toggle(this)">hasTemplateArgument</td><td>unsigned N, internal::Matcher&lt;TemplateArgument> Matcher</td></tr>
<tr><td colspan="4" class="doc" id="hasTemplateArgument"><pre>\brief Matches classTemplateSpecializations where the n'th TemplateArgument
matches the given Matcher.

Given
  template&lt;typename T, typename U> class A {};
  A&lt;bool, int> b;
  A&lt;int, bool> c;
classTemplateSpecialization(hasTemplateArgument(
    1, refersToType(asString("int"))))
  matches the specialization \c A&lt;bool, int>
</pre></td></tr>


<tr><td>Matcher&lt;CompoundStmt&gt;</td><td class="name" onclick="toggle(this)">hasAnySubstatement</td><td>internal::Matcher&lt;Stmt> InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasAnySubstatement"><pre>\brief Matches compound statements where at least one substatement matches
a given matcher.

Given
  { {}; 1+2; }
hasAnySubstatement(compoundStatement())
  matches '{ {}; 1+2; }'
with compoundStatement()
  matching '{}'
</pre></td></tr>


<tr><td>Matcher&lt;ConditionalOperator&gt;</td><td class="name" onclick="toggle(this)">hasCondition</td><td>internal::Matcher&lt;Expr> InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasCondition"><pre>\brief Matches the condition expression of an if statement, for loop,
or conditional operator.

Example matches true (matcher = hasCondition(boolLiteral(equals(true))))
  if (true) {}
</pre></td></tr>


<tr><td>Matcher&lt;ConditionalOperator&gt;</td><td class="name" onclick="toggle(this)">hasFalseExpression</td><td>internal::Matcher&lt;Expr> InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasFalseExpression"><pre>\brief Matches the false branch expression of a conditional operator.

Example matches b
  condition ? a : b
</pre></td></tr>


<tr><td>Matcher&lt;ConditionalOperator&gt;</td><td class="name" onclick="toggle(this)">hasTrueExpression</td><td>internal::Matcher&lt;Expr> InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasTrueExpression"><pre>\brief Matches the true branch expression of a conditional operator.

Example matches a
  condition ? a : b
</pre></td></tr>


<tr><td>Matcher&lt;DeclRefExpr&gt;</td><td class="name" onclick="toggle(this)">throughUsingDecl</td><td>internal::Matcher&lt;UsingShadowDecl> Matcher</td></tr>
<tr><td colspan="4" class="doc" id="throughUsingDecl"><pre>\brief Matches a \c DeclRefExpr that refers to a declaration through a
specific using shadow declaration.

FIXME: This currently only works for functions. Fix.

Given
  namespace a { void f() {} }
  using a::f;
  void g() {
    f();     Matches this ..
    a::f();  .. but not this.
  }
declarationReference(throughUsingDeclaration(anything()))
  matches \c f()
</pre></td></tr>


<tr><td>Matcher&lt;DeclRefExpr&gt;</td><td class="name" onclick="toggle(this)">to</td><td>internal::Matcher&lt;Decl> InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="to"><pre>\brief Matches a DeclRefExpr that refers to a declaration that matches the
specified matcher.

Example matches x in if(x)
    (matcher = declarationReference(to(variable(hasName("x")))))
  bool x;
  if (x) {}
</pre></td></tr>


<tr><td>Matcher&lt;DeclStmt&gt;</td><td class="name" onclick="toggle(this)">containsDeclaration</td><td>unsigned N, internal::Matcher&lt;Decl> InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="containsDeclaration"><pre>\brief Matches the n'th declaration of a declaration statement.

Note that this does not work for global declarations because the AST
breaks up multiple-declaration DeclStmt's into multiple single-declaration
DeclStmt's.
Example: Given non-global declarations
  int a, b = 0;
  int c;
  int d = 2, e;
declarationStatement(containsDeclaration(
      0, variable(hasInitializer(anything()))))
  matches only 'int d = 2, e;', and
declarationStatement(containsDeclaration(1, variable()))
  matches 'int a, b = 0' as well as 'int d = 2, e;'
  but 'int c;' is not matched.
</pre></td></tr>


<tr><td>Matcher&lt;DeclStmt&gt;</td><td class="name" onclick="toggle(this)">hasSingleDecl</td><td>internal::Matcher&lt;Decl> InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasSingleDecl"><pre>\brief Matches the Decl of a DeclStmt which has a single declaration.

Given
  int a, b;
  int c;
declarationStatement(hasSingleDecl(anything()))
  matches 'int c;' but not 'int a, b;'.
</pre></td></tr>


<tr><td>Matcher&lt;DoStmt&gt;</td><td class="name" onclick="toggle(this)">hasBody</td><td>internal::Matcher&lt;Stmt> InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasBody"><pre>\brief Matches a 'for', 'while', or 'do while' statement that has
a given body.

Given
  for (;;) {}
hasBody(compoundStatement())
  matches 'for (;;) {}'
with compoundStatement()
  matching '{}'
</pre></td></tr>


<tr><td>Matcher&lt;DoStmt&gt;</td><td class="name" onclick="toggle(this)">hasCondition</td><td>internal::Matcher&lt;Expr> InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasCondition"><pre>\brief Matches the condition expression of an if statement, for loop,
or conditional operator.

Example matches true (matcher = hasCondition(boolLiteral(equals(true))))
  if (true) {}
</pre></td></tr>


<tr><td>Matcher&lt;ExplicitCastExpr&gt;</td><td class="name" onclick="toggle(this)">hasDestinationType</td><td>internal::Matcher&lt;QualType> InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasDestinationType"><pre>\brief Matches casts whose destination type matches a given matcher.

(Note: Clang's AST refers to other conversions as "casts" too, and calls
actual casts "explicit" casts.)
</pre></td></tr>


<tr><td>Matcher&lt;Expr&gt;</td><td class="name" onclick="toggle(this)">hasType</td><td>const internal::Matcher&lt;Decl> &amp;InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasType"><pre>\brief Overloaded to match the declaration of the expression's or value
declaration's type.

In case of a value declaration (for example a variable declaration),
this resolves one layer of indirection. For example, in the value
declaration "X x;", record(hasName("X")) matches the declaration of X,
while variable(hasType(record(hasName("X")))) matches the declaration
of x."

Example matches x (matcher = expression(hasType(record(hasName("X")))))
            and z (matcher = variable(hasType(record(hasName("X")))))
 class X {};
 void y(X &amp;x) { x; X z; }

Usable as: Matcher&lt;Expr>, Matcher&lt;ValueDecl>
</pre></td></tr>


<tr><td>Matcher&lt;Expr&gt;</td><td class="name" onclick="toggle(this)">ignoringImpCasts</td><td>internal::Matcher&lt;Expr> InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="ignoringImpCasts"><pre>\brief Matches expressions that match InnerMatcher after any implicit casts
are stripped off.

Parentheses and explicit casts are not discarded.
Given
  int arr[5];
  int a = 0;
  char b = 0;
  const int c = a;
  int *d = arr;
  long e = (long) 0l;
The matchers
   variable(hasInitializer(ignoringImpCasts(integerLiteral())))
   variable(hasInitializer(ignoringImpCasts(declarationReference())))
would match the declarations for a, b, c, and d, but not e.
while
   variable(hasInitializer(integerLiteral()))
   variable(hasInitializer(declarationReference()))
only match the declarations for b, c, and d.
</pre></td></tr>


<tr><td>Matcher&lt;Expr&gt;</td><td class="name" onclick="toggle(this)">ignoringParenCasts</td><td>internal::Matcher&lt;Expr> InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="ignoringParenCasts"><pre>\brief Matches expressions that match InnerMatcher after parentheses and
casts are stripped off.

Implicit and non-C Style casts are also discarded.
Given
  int a = 0;
  char b = (0);
  void* c = reinterpret_cast&lt;char*>(0);
  char d = char(0);
The matcher
   variable(hasInitializer(ignoringParenCasts(integerLiteral())))
would match the declarations for a, b, c, and d.
while
   variable(hasInitializer(integerLiteral()))
only match the declaration for a.
</pre></td></tr>


<tr><td>Matcher&lt;Expr&gt;</td><td class="name" onclick="toggle(this)">ignoringParenImpCasts</td><td>internal::Matcher&lt;Expr> InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="ignoringParenImpCasts"><pre>\brief Matches expressions that match InnerMatcher after implicit casts and
parentheses are stripped off.

Explicit casts are not discarded.
Given
  int arr[5];
  int a = 0;
  char b = (0);
  const int c = a;
  int *d = (arr);
  long e = ((long) 0l);
The matchers
   variable(hasInitializer(ignoringParenImpCasts(
      integerLiteral())))
   variable(hasInitializer(ignoringParenImpCasts(
      declarationReference())))
would match the declarations for a, b, c, and d, but not e.
while
   variable(hasInitializer(integerLiteral()))
   variable(hasInitializer(declarationReference()))
would only match the declaration for a.
</pre></td></tr>


<tr><td>Matcher&lt;ForStmt&gt;</td><td class="name" onclick="toggle(this)">hasBody</td><td>internal::Matcher&lt;Stmt> InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasBody"><pre>\brief Matches a 'for', 'while', or 'do while' statement that has
a given body.

Given
  for (;;) {}
hasBody(compoundStatement())
  matches 'for (;;) {}'
with compoundStatement()
  matching '{}'
</pre></td></tr>


<tr><td>Matcher&lt;ForStmt&gt;</td><td class="name" onclick="toggle(this)">hasCondition</td><td>internal::Matcher&lt;Expr> InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasCondition"><pre>\brief Matches the condition expression of an if statement, for loop,
or conditional operator.

Example matches true (matcher = hasCondition(boolLiteral(equals(true))))
  if (true) {}
</pre></td></tr>


<tr><td>Matcher&lt;ForStmt&gt;</td><td class="name" onclick="toggle(this)">hasIncrement</td><td>internal::Matcher&lt;Stmt> InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasIncrement"><pre>\brief Matches the increment statement of a for loop.

Example:
    forStmt(hasIncrement(unaryOperator(hasOperatorName("++"))))
matches '++x' in
    for (x; x &lt; N; ++x) { }
</pre></td></tr>


<tr><td>Matcher&lt;ForStmt&gt;</td><td class="name" onclick="toggle(this)">hasLoopInit</td><td>internal::Matcher&lt;Stmt> InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasLoopInit"><pre>\brief Matches the initialization statement of a for loop.

Example:
    forStmt(hasLoopInit(declarationStatement()))
matches 'int x = 0' in
    for (int x = 0; x &lt; N; ++x) { }
</pre></td></tr>


<tr><td>Matcher&lt;FunctionDecl&gt;</td><td class="name" onclick="toggle(this)">hasAnyParameter</td><td>internal::Matcher&lt;ParmVarDecl> InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasAnyParameter"><pre>\brief Matches any parameter of a function declaration.

Does not match the 'this' parameter of a method.

Given
  class X { void f(int x, int y, int z) {} };
method(hasAnyParameter(hasName("y")))
  matches f(int x, int y, int z) {}
with hasAnyParameter(...)
  matching int y
</pre></td></tr>


<tr><td>Matcher&lt;FunctionDecl&gt;</td><td class="name" onclick="toggle(this)">hasParameter</td><td>unsigned N, internal::Matcher&lt;ParmVarDecl> InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasParameter"><pre>\brief Matches the n'th parameter of a function declaration.

Given
  class X { void f(int x) {} };
method(hasParameter(0, hasType(variable())))
  matches f(int x) {}
with hasParameter(...)
  matching int x
</pre></td></tr>


<tr><td>Matcher&lt;FunctionDecl&gt;</td><td class="name" onclick="toggle(this)">returns</td><td>internal::Matcher&lt;QualType> Matcher</td></tr>
<tr><td colspan="4" class="doc" id="returns"><pre>\brief Matches the return type of a function declaration.

Given:
  class X { int f() { return 1; } };
method(returns(asString("int")))
  matches int f() { return 1; }
</pre></td></tr>


<tr><td>Matcher&lt;IfStmt&gt;</td><td class="name" onclick="toggle(this)">hasCondition</td><td>internal::Matcher&lt;Expr> InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasCondition"><pre>\brief Matches the condition expression of an if statement, for loop,
or conditional operator.

Example matches true (matcher = hasCondition(boolLiteral(equals(true))))
  if (true) {}
</pre></td></tr>


<tr><td>Matcher&lt;IfStmt&gt;</td><td class="name" onclick="toggle(this)">hasConditionVariableStatement</td><td>internal::Matcher&lt;DeclStmt> InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasConditionVariableStatement"><pre>\brief Matches the condition variable statement in an if statement.

Given
  if (A* a = GetAPointer()) {}
hasConditionVariableStatment(...)
  matches 'A* a = GetAPointer()'.
</pre></td></tr>


<tr><td>Matcher&lt;ImplicitCastExpr&gt;</td><td class="name" onclick="toggle(this)">hasImplicitDestinationType</td><td>internal::Matcher&lt;QualType> InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasImplicitDestinationType"><pre>\brief Matches implicit casts whose destination type matches a given
matcher.

FIXME: Unit test this matcher
</pre></td></tr>


<tr><td>Matcher&lt;MemberExpr&gt;</td><td class="name" onclick="toggle(this)">hasObjectExpression</td><td>internal::Matcher&lt;Expr> InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasObjectExpression"><pre>\brief Matches a member expression where the object expression is
matched by a given matcher.

Given
  struct X { int m; };
  void f(X x) { x.m; m; }
memberExpression(hasObjectExpression(hasType(record(hasName("X")))))))
  matches "x.m" and "m"
with hasObjectExpression(...)
  matching "x" and the implicit object expression of "m" which has type X*.
</pre></td></tr>


<tr><td>Matcher&lt;MemberExpr&gt;</td><td class="name" onclick="toggle(this)">member</td><td>internal::Matcher&lt;ValueDecl> InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="member"><pre>\brief Matches a member expression where the member is matched by a
given matcher.

Given
  struct { int first, second; } first, second;
  int i(second.first);
  int j(first.second);
memberExpression(member(hasName("first")))
  matches second.first
  but not first.second (because the member name there is "second").
</pre></td></tr>


<tr><td>Matcher&lt;QualType&gt;</td><td class="name" onclick="toggle(this)">hasDeclaration</td><td>const internal::Matcher&lt;Decl> &amp;InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasDeclaration"><pre>\brief Matches a type if the declaration of the type matches the given
matcher.

Usable as: Matcher&lt;QualType>, Matcher&lt;CallExpr>, Matcher&lt;CXXConstructExpr>
</pre></td></tr>


<tr><td>Matcher&lt;QualType&gt;</td><td class="name" onclick="toggle(this)">pointsTo</td><td>const internal::Matcher&lt;Decl> &amp;InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="pointsTo"><pre>\brief Overloaded to match the pointee type's declaration.
</pre></td></tr>


<tr><td>Matcher&lt;QualType&gt;</td><td class="name" onclick="toggle(this)">references</td><td>const internal::Matcher&lt;Decl> &amp;InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="references"><pre>\brief Overloaded to match the referenced type's declaration.
</pre></td></tr>


<tr><td>Matcher&lt;Stmt&gt;</td><td class="name" onclick="toggle(this)">alignOfExpr</td><td>const internal::Matcher&lt;UnaryExprOrTypeTraitExpr> &amp;Matcher</td></tr>
<tr><td colspan="4" class="doc" id="alignOfExpr"><pre>\brief Same as unaryExprOrTypeTraitExpr, but only matching
alignof.
</pre></td></tr>


<tr><td>Matcher&lt;Stmt&gt;</td><td class="name" onclick="toggle(this)">sizeOfExpr</td><td>const internal::Matcher&lt;UnaryExprOrTypeTraitExpr> &amp;Matcher</td></tr>
<tr><td colspan="4" class="doc" id="sizeOfExpr"><pre>\brief Same as unaryExprOrTypeTraitExpr, but only matching
sizeof.
</pre></td></tr>


<tr><td>Matcher&lt;TemplateArgument&gt;</td><td class="name" onclick="toggle(this)">refersToDeclaration</td><td>internal::Matcher&lt;Decl> Matcher</td></tr>
<tr><td colspan="4" class="doc" id="refersToDeclaration"><pre>\brief Matches a TemplateArgument that refers to a certain declaration.

Given
  template&lt;typename T> struct A {};
  struct B { B* next; };
  A&lt;&amp;B::next> a;
classTemplateSpecialization(hasAnyTemplateArgument(
    refersToDeclaration(field(hasName("next"))))
  matches the specialization \c A&lt;&amp;B::next> with \c field(...) matching
    \c B::next
</pre></td></tr>


<tr><td>Matcher&lt;TemplateArgument&gt;</td><td class="name" onclick="toggle(this)">refersToType</td><td>internal::Matcher&lt;QualType> Matcher</td></tr>
<tr><td colspan="4" class="doc" id="refersToType"><pre>\brief Matches a TemplateArgument that refers to a certain type.

Given
  struct X {};
  template&lt;typename T> struct A {};
  A&lt;X> a;
classTemplateSpecialization(hasAnyTemplateArgument(
    refersToType(class(hasName("X")))))
  matches the specialization \c A&lt;X>
</pre></td></tr>


<tr><td>Matcher&lt;T&gt;</td><td class="name" onclick="toggle(this)">id</td><td>const std::string &amp;ID, const internal::BindableMatcher&lt;T> &amp;InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="id"><pre>\brief If the provided matcher matches a node, binds the node to 'ID'.

FIXME: Add example for accessing it.
</pre></td></tr>


<tr><td>Matcher&lt;UnaryExprOrTypeTraitExpr&gt;</td><td class="name" onclick="toggle(this)">hasArgumentOfType</td><td>internal::Matcher&lt;QualType> Matcher</td></tr>
<tr><td colspan="4" class="doc" id="hasArgumentOfType"><pre>\brief Matches unary expressions that have a specific type of argument.

Given
  int a, c; float b; int s = sizeof(a) + sizeof(b) + alignof(c);
unaryExprOrTypeTraitExpr(hasArgumentOfType(asString("int"))
  matches \c sizeof(a) and \c alignof(c)
</pre></td></tr>


<tr><td>Matcher&lt;UnaryOperator&gt;</td><td class="name" onclick="toggle(this)">hasUnaryOperand</td><td>internal::Matcher&lt;Expr> InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasUnaryOperand"><pre>\brief Matches if the operand of a unary operator matches.

Example matches true (matcher = hasOperand(boolLiteral(equals(true))))
  !true
</pre></td></tr>


<tr><td>Matcher&lt;UsingDecl&gt;</td><td class="name" onclick="toggle(this)">hasAnyUsingShadowDecl</td><td>internal::Matcher&lt;UsingShadowDecl> Matcher</td></tr>
<tr><td colspan="4" class="doc" id="hasAnyUsingShadowDecl"><pre>\brief Matches any using shadow declaration.

Given
  namespace X { void b(); }
  using X::b;
usingDecl(hasAnyUsingShadowDecl(hasName("b"))))
  matches \code using X::b \endcode
</pre></td></tr>


<tr><td>Matcher&lt;UsingShadowDecl&gt;</td><td class="name" onclick="toggle(this)">hasTargetDecl</td><td>internal::Matcher&lt;NamedDecl> Matcher</td></tr>
<tr><td colspan="4" class="doc" id="hasTargetDecl"><pre>\brief Matches a using shadow declaration where the target declaration is
matched by the given matcher.

Given
  namespace X { int a; void b(); }
  using X::a;
  using X::b;
usingDecl(hasAnyUsingShadowDecl(hasTargetDecl(function())))
  matches \code using X::b \endcode
  but not \code using X::a \endcode
</pre></td></tr>


<tr><td>Matcher&lt;ValueDecl&gt;</td><td class="name" onclick="toggle(this)">hasType</td><td>const internal::Matcher&lt;Decl> &amp;InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasType"><pre>\brief Overloaded to match the declaration of the expression's or value
declaration's type.

In case of a value declaration (for example a variable declaration),
this resolves one layer of indirection. For example, in the value
declaration "X x;", record(hasName("X")) matches the declaration of X,
while variable(hasType(record(hasName("X")))) matches the declaration
of x."

Example matches x (matcher = expression(hasType(record(hasName("X")))))
            and z (matcher = variable(hasType(record(hasName("X")))))
 class X {};
 void y(X &amp;x) { x; X z; }

Usable as: Matcher&lt;Expr>, Matcher&lt;ValueDecl>
</pre></td></tr>


<tr><td>Matcher&lt;VarDecl&gt;</td><td class="name" onclick="toggle(this)">hasInitializer</td><td>internal::Matcher&lt;Expr> InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasInitializer"><pre>\brief Matches a variable declaration that has an initializer expression
that matches the given matcher.

Example matches x (matcher = variable(hasInitializer(call())))
  bool y() { return true; }
  bool x = y();
</pre></td></tr>


<tr><td>Matcher&lt;WhileStmt&gt;</td><td class="name" onclick="toggle(this)">hasBody</td><td>internal::Matcher&lt;Stmt> InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasBody"><pre>\brief Matches a 'for', 'while', or 'do while' statement that has
a given body.

Given
  for (;;) {}
hasBody(compoundStatement())
  matches 'for (;;) {}'
with compoundStatement()
  matching '{}'
</pre></td></tr>


<tr><td>Matcher&lt;WhileStmt&gt;</td><td class="name" onclick="toggle(this)">hasCondition</td><td>internal::Matcher&lt;Expr> InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasCondition"><pre>\brief Matches the condition expression of an if statement, for loop,
or conditional operator.

Example matches true (matcher = hasCondition(boolLiteral(equals(true))))
  if (true) {}
</pre></td></tr>

<!--END_TRAVERSAL_MATCHERS -->
</table>

</div>
</body>
</html>


